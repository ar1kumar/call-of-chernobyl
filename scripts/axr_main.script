--[[
Copyright (C) 2012-2015 Alundaio
This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License

Callback and module manager for easy plug-in based script management
by Alundaio

1/31/2016
axr_main now auto-executes any script that has on_game_load method. To create a new module, simply
add a on_game_start function
--]]

-- axr_options.ini
config = alun_utils.cfg_file(getFS():update_path('$game_data$', '').."axr_options.ini",true)
-------------------------------------------------------------------------------------------------

-- Valid Callbacks (named intercepts to avoid namespace conflicts)
-- You must register a callback before or during on_game_load (ie. bind_actor net_spawn)
-- All unused callbacks will have their table deleted from intercepts (see on_game_load for implementation)
local intercepts = {
	-- _g.script

	-- ui_main_menu.script
	main_menu_on_keyboard		= {},
	main_menu_on_init			= {},
--	main_menu_on_init_callbacks	= {},
	main_menu_on_quit			= {},

	-- ui_mm_opt_main.script 
	opt_menu_on_init			= {},
	opt_menu_on_accept			= {},
	opt_menu_on_set_values		= {},
	
	-- xr_motivator.script
	npc_on_use 					= {},
	npc_on_item_take 			= {},
	npc_on_item_drop 			= {},
	npc_on_net_spawn			= {},
	npc_on_net_destroy 			= {},
	npc_on_update				= {},
	npc_on_hit_callback			= {},
	npc_on_death_callback		= {},
	npc_on_item_take_from_box	= {},
	
	-- xr_combat_ignore.script
	npc_on_fighting_actor		= {},
	
	-- state_mgr_weapon.script
	npc_on_weapon_strapped		= {},
	npc_on_weapon_unstrapped	= {},
	npc_on_weapon_drop			= {},

	-- xr_hear.script
	npc_on_hear_callback		= {},

	-- se_stalker.script
	se_stalker_on_spawn			= {},

	-- se_actor.script
	se_actor_on_register		= {},
	se_actor_on_unregister		= {},
	se_actor_on_STATE_Write		= {},
	se_actor_on_STATE_Read		= {},

	-- xr_corpse_detection.script
	npc_on_get_all_from_corpse 	= {},

	-- sim_board.script
	squad_on_npc_creation		= {},
	
	-- sim_squad_scripted.script
	squad_assign_new_target		= {},
	squad_can_help_actor		= {},
	squad_on_npc_death			= {},
	squad_on_update				= {},
	squad_on_add_npc			= {},
	squad_can_switch_offline	= {},
	squad_on_unregister			= {},

	-- xr_logic.script
	on_pstor_save_all			= {},
	on_pstor_load_all			= {},

	-- bind_stalker_ext.script
	on_level_changing			= {},
	on_key_press				= {},
	on_key_release				= {},
	on_key_hold					= {},
	actor_on_before_death		= {},
	on_game_load				= {},
	actor_on_net_destroy		= {},
	actor_on_first_update		= {},
	actor_on_update				= {},
	--actor_on_weapon_no_ammo		= {},	-- TODO: Export from engine instead
	actor_on_weapon_zoom_in		= {},
	actor_on_weapon_zoom_out	= {},
	actor_on_item_take			= {},
	actor_on_item_take_from_box = {},
	actor_on_item_drop			= {},
	actor_on_item_use			= {},
	actor_on_trade				= {},
	actor_on_save				= {},
	actor_on_load				= {},
	actor_on_init				= {},
	actor_on_torch_enabled		= {},	-- TODO: Export from engine instead
	actor_on_torch_disabled		= {},	-- TODO: Export from engine instead
	actor_on_info_callback		= {},
	actor_on_hit_callback		= {},
	actor_on_attach_vehicle		= {},
	actor_on_detach_vehicle		= {},
	actor_on_use_vehicle		= {},
	
	-- pda.script
	actor_on_leave_dialog		= {},

	-- bind_monster.script
	monster_on_update				= {},
	monster_on_hit_callback			= {},
	monster_on_net_spawn			= {},
	monster_on_death_callback		= {},
	monster_on_actor_use_callback   = {},

	-- bind_physic_object.script
	physic_object_on_hit_callback 	= {},
	physic_object_on_use_callback 	= {},
	
	-- Custom saving feature (uses marshal)
	save_state						= {},
	load_state						= {},
	
	TrdWndOpened					= {},
	TrdWndClosed					= {}
}

-----------------------------------------------------------
-- Global Callback Register
-- param 1 - name as type<string> (ie. intercepts[name])
-- param 2 - function to execute as type<function> or type<table>
-----------------------------------------------------------
function callback_set(name,func,userdata)
	--printf("callback_set %s",name)
	if not (func) then
		return
	end
	if (intercepts[name]) then
		if (userdata) then 
			local function wrapper(...)
				func(userdata,...)
			end
			intercepts[name][userdata] = wrapper
		else
			intercepts[name][func] = func
		end
	end
end

function callback_unset(name,func_or_userdata)
	if not (intercepts[name]) then
		return
	end
	intercepts[name][func_or_userdata] = nil
end

function make_callback(name,...)
	if not (intercepts[name]) then
		return 
	end
	
	for k,func in pairs(intercepts[name]) do
		--printf("make_callback %s",name)
		--[[
		if not (pcall(function(...) func(...) end)) then
			error(strformat("axr_main.make_callback failed %s",name))
		end
		--]]
		func(...)
	end 
end

--------------------------------------------------------------------------------------------------------------------
-- ON GAME START
--------------------------------------------------------------------------------------------------------------------
function on_game_start()
	local ignore = { 
		["_g.script"] = true,
		["ce_new_attachable_item.script"] = true,
		["ce_new_game_dm.script"] = true,
		["sim_faction_brain_human.script"] = true,
		["sim_faction_brain_mutant.script"] = true,
		["ce_switcher.script"] = true,
		["axr_main.script"] = true,
		["lua_help.script"] = true,
		["rx_gl.script"] = true
	}
	local t = {}
	local f	= getFS()
	local flist = f:file_list_open_ex("$game_scripts$",bit_or(FS.FS_ListFiles,FS.FS_RootOnly),"*.script")
	local f_cnt = flist:Size()
	for	it=0, f_cnt-1 do
		local file = flist:GetAt(it)
		local file_name = file:NameShort()
		if not (ignore[file_name]) then
			file_name = file_name:sub(0,file_name:len()-7)
			if (_G[file_name] and _G[file_name].on_game_start) then
				table.insert(t,file_name) -- load all scripts first
			end
		end
	end
	for i=1,#t do
		printf("axr_main module added %s",t[i])
		_G[t[i]].on_game_start()
	end
end

-------------------
-- squad_can_switch_offline(self)
-------------------
function squad_can_switch_offline(squad,npc)
	if (intercepts.squad_can_switch_offline) then 
		for k, func in pairs(intercepts.squad_can_switch_offline) do
			if (func(squad) == false) then
				return false
			end
		end
	end
end

-------------------
-- squad_assign_new_target(squad)
-------------------
function squad_assign_new_target(squad)
	if (intercepts.squad_assign_new_target) then
		local id
		for k, func in pairs(intercepts.squad_assign_new_target) do
			id = func(squad)
			if (id) then
				break
			end
		end
		return id
	end
end

-------------------
-- squad_can_help_actor(squad)
-------------------
function squad_can_help_actor(squad)
	if (intercepts.squad_can_help_actor) then 
		local flag
		for k, func in pairs(intercepts.squad_can_help_actor) do
			flag = func(squad)
			if (flag) then
				break
			end
		end
		return flag
	end
end

------------------
-- main_menu_on_init()
------------------
function main_menu_on_init(menu)
	xrs_dyn_music.main_menu_on(menu)
	closecaption.main_menu_on_init(menu)
	axr_main_options.main_menu_on_init(menu)
end

------------------
-- main_menu_on_quit()
------------------
function main_menu_on_quit(menu)
	closecaption.main_menu_on_quit(menu)
	xrs_dyn_music.main_menu_off(menu)
end

------------------
-- opt_menu_on_init()
------------------
function opt_menu_on_init(menu)
	axr_main_options.opt_menu_on_init(menu)
end

------------------
-- opt_menu_on_accept()
------------------
function opt_menu_on_accept(menu,optMgr,console)
	axr_main_options.opt_menu_on_accept(menu,optMgr,console)
end

------------------
-- opt_menu_on_set_values()
------------------
function opt_menu_on_set_values(menu,optMgr)
	axr_main_options.opt_menu_on_set_values(menu,optMgr)
end

function actor_on_weapon_zoom_in()
	weapon_is_zoomed = true
end 

function actor_on_weapon_zoom_out()
	weapon_is_zoomed = false
end
